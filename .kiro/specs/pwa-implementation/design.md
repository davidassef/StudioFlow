# Design Document - PWA Implementation

## Overview

Este documento detalha o design técnico para transformar o StudioFlow em um Progressive Web App (PWA) completo. A implementação será feita sobre a base existente do Next.js 14, adicionando as funcionalidades PWA essenciais sem quebrar a arquitetura atual.

## Architecture

### PWA Architecture Stack

```
┌─────────────────────────────────────────────────────────────┐
│                    StudioFlow PWA                           │
├─────────────────────────────────────────────────────────────┤
│  Frontend (Next.js 14 + PWA)                               │
│  ├── App Shell (Cached UI Framework)                       │
│  ├── Service Worker (Caching + Background Sync)            │
│  ├── Web App Manifest (Installation Config)                │
│  └── Push Notification Service                             │
├─────────────────────────────────────────────────────────────┤
│  Existing Backend (Django + DRF)                           │
│  ├── REST APIs (Already implemented)                       │
│  ├── WebSocket (Real-time notifications)                   │
│  └── Push Notification Server                              │
├─────────────────────────────────────────────────────────────┤
│  Data Layer                                                 │
│  ├── IndexedDB (Offline storage)                           │
│  ├── Cache API (Static assets)                             │
│  └── Background Sync Queue                                 │
└─────────────────────────────────────────────────────────────┘
```

### PWA Core Components Integration

1. **Next.js PWA Plugin**: `next-pwa` para configuração automática
2. **Workbox**: Service Worker com estratégias de cache inteligentes
3. **Web Push**: Notificações push usando protocolo padrão
4. **IndexedDB**: Armazenamento offline de dados críticos

## Components and Interfaces

### 1. PWA Configuration Layer

#### Web App Manifest (`public/manifest.json`)
```json
{
  "name": "StudioFlow - Gestão de Estúdios",
  "short_name": "StudioFlow",
  "description": "Sistema completo para gestão de estúdios musicais",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#3b82f6",
  "orientation": "portrait-primary",
  "categories": ["business", "music", "productivity"],
  "icons": [
    {
      "src": "/icons/icon-72x72.png",
      "sizes": "72x72",
      "type": "image/png",
      "purpose": "maskable any"
    },
    // ... outros tamanhos
  ]
}
```

#### Next.js PWA Configuration (`next.config.js`)
```javascript
const withPWA = require('next-pwa')({
  dest: 'public',
  register: true,
  skipWaiting: true,
  runtimeCaching: [
    {
      urlPattern: /^https:\/\/localhost:5000\/api\//,
      handler: 'NetworkFirst',
      options: {
        cacheName: 'api-cache',
        expiration: {
          maxEntries: 100,
          maxAgeSeconds: 24 * 60 * 60 // 24 hours
        }
      }
    }
  ]
})

module.exports = withPWA({
  // existing config
})
```

### 2. Service Worker Strategy

#### Cache Strategies by Content Type

1. **App Shell** (HTML, CSS, JS): `CacheFirst`
   - Arquivos estáticos da aplicação
   - Atualização apenas em nova versão

2. **API Data** (REST endpoints): `NetworkFirst`
   - Dados dinâmicos com fallback para cache
   - TTL de 24 horas para dados não críticos

3. **Images**: `CacheFirst` com `StaleWhileRevalidate`
   - Imagens de estúdios e perfis
   - Cache persistente com atualização em background

4. **Critical Data**: `NetworkOnly` com Background Sync
   - Agendamentos em tempo real
   - Dados financeiros sensíveis

#### Service Worker Structure
```typescript
// sw.js (generated by next-pwa)
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching'
import { registerRoute } from 'workbox-routing'
import { NetworkFirst, CacheFirst, StaleWhileRevalidate } from 'workbox-strategies'

// Precache app shell
precacheAndRoute(self.__WB_MANIFEST)
cleanupOutdatedCaches()

// API caching strategy
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-cache',
    plugins: [
      {
        cacheKeyWillBeUsed: async ({ request }) => {
          return `${request.url}?timestamp=${Date.now()}`
        }
      }
    ]
  })
)
```

### 3. Offline Data Management

#### IndexedDB Schema
```typescript
interface OfflineStore {
  agendamentos: {
    id: string
    data: AgendamentoData
    lastSync: number
    status: 'synced' | 'pending' | 'conflict'
  }
  
  salas: {
    id: string
    data: SalaData
    lastSync: number
  }
  
  userPreferences: {
    key: string
    value: any
    lastUpdated: number
  }
  
  syncQueue: {
    id: string
    action: 'create' | 'update' | 'delete'
    resource: string
    data: any
    timestamp: number
    retryCount: number
  }
}
```

#### Offline Manager Service
```typescript
class OfflineManager {
  private db: IDBDatabase
  
  async cacheEssentialData(): Promise<void> {
    // Cache user's agendamentos
    // Cache salas favoritas
    // Cache configurações do usuário
  }
  
  async queueAction(action: OfflineAction): Promise<void> {
    // Add to sync queue
    // Attempt immediate sync if online
  }
  
  async syncWhenOnline(): Promise<void> {
    // Process sync queue
    // Resolve conflicts
    // Update local cache
  }
}
```

### 4. Push Notification System

#### Frontend Push Manager
```typescript
class PushNotificationManager {
  private registration: ServiceWorkerRegistration
  
  async requestPermission(): Promise<NotificationPermission> {
    return await Notification.requestPermission()
  }
  
  async subscribe(): Promise<PushSubscription> {
    const subscription = await this.registration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: process.env.NEXT_PUBLIC_VAPID_KEY
    })
    
    // Send subscription to backend
    await this.sendSubscriptionToServer(subscription)
    return subscription
  }
  
  async handlePushEvent(event: PushEvent): Promise<void> {
    const data = event.data?.json()
    
    await self.registration.showNotification(data.title, {
      body: data.body,
      icon: '/icons/icon-192x192.png',
      badge: '/icons/badge-72x72.png',
      actions: data.actions,
      data: data.payload
    })
  }
}
```

#### Backend Push Integration (Django)
```python
# New Django app: push_notifications
class PushSubscription(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    endpoint = models.URLField()
    p256dh_key = models.CharField(max_length=255)
    auth_key = models.CharField(max_length=255)
    created_at = models.DateTimeField(auto_now_add=True)

class PushNotificationService:
    def send_booking_confirmation(self, booking_id: int):
        # Send push to client
        # Send push to studio owner
        
    def send_booking_reminder(self, booking_id: int):
        # Send 1 hour before booking
        
    def send_new_booking_request(self, studio_id: int):
        # Notify studio owner of new request
```

### 5. Mobile-First UI Enhancements

#### Touch-Optimized Components
```typescript
// Enhanced Button component for mobile
interface TouchButtonProps extends ButtonProps {
  hapticFeedback?: boolean
  touchRipple?: boolean
  minTouchTarget?: number // 44px minimum
}

// Swipe gesture support for calendar
interface SwipeCalendarProps {
  onSwipeLeft?: () => void
  onSwipeRight?: () => void
  enableSwipeNavigation?: boolean
}

// Pull-to-refresh for data lists
interface PullToRefreshProps {
  onRefresh: () => Promise<void>
  refreshThreshold?: number
  children: React.ReactNode
}
```

#### Responsive Layout Improvements
```css
/* Enhanced mobile styles */
@media (max-width: 768px) {
  .dashboard-grid {
    grid-template-columns: 1fr;
    gap: 1rem;
  }
  
  .booking-form {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    border-radius: 1rem 1rem 0 0;
  }
  
  .navigation {
    position: fixed;
    bottom: 0;
    height: 60px;
    padding-bottom: env(safe-area-inset-bottom);
  }
}
```

## Data Models

### PWA-Specific Data Structures

#### Installation State
```typescript
interface PWAInstallState {
  isInstallable: boolean
  isInstalled: boolean
  installPrompt: BeforeInstallPromptEvent | null
  installationSource: 'browser' | 'homescreen' | 'store'
}
```

#### Offline Sync State
```typescript
interface SyncState {
  isOnline: boolean
  lastSyncTime: Date
  pendingActions: number
  syncInProgress: boolean
  conflicts: SyncConflict[]
}

interface SyncConflict {
  id: string
  resource: string
  localData: any
  serverData: any
  conflictType: 'update' | 'delete'
  timestamp: Date
}
```

#### Push Notification Data
```typescript
interface PushNotificationData {
  type: 'booking_confirmed' | 'booking_reminder' | 'new_request'
  title: string
  body: string
  actions?: NotificationAction[]
  payload: {
    bookingId?: string
    studioId?: string
    url: string
  }
}
```

## Error Handling

### PWA-Specific Error Scenarios

1. **Installation Failures**
   - Manifest parsing errors
   - Service worker registration failures
   - Icon loading issues

2. **Offline Functionality**
   - Cache corruption
   - IndexedDB quota exceeded
   - Sync queue overflow

3. **Push Notifications**
   - Permission denied
   - Subscription failures
   - Message delivery failures

4. **Cross-Platform Issues**
   - iOS Safari limitations
   - Android Chrome variations
   - Desktop browser differences

### Error Recovery Strategies

```typescript
class PWAErrorHandler {
  async handleInstallationError(error: Error): Promise<void> {
    // Log error details
    // Provide fallback web experience
    // Show user-friendly message
  }
  
  async handleOfflineError(error: Error): Promise<void> {
    // Clear corrupted cache
    // Reset IndexedDB if needed
    // Notify user of data loss risk
  }
  
  async handlePushError(error: Error): Promise<void> {
    // Retry subscription
    // Fall back to in-app notifications
    // Update user preferences
  }
}
```

## Testing Strategy

### PWA Testing Approach

1. **Lighthouse PWA Audit**
   - Automated PWA compliance testing
   - Performance benchmarking
   - Accessibility validation

2. **Cross-Browser Testing**
   - Chrome (Android/Desktop)
   - Safari (iOS/macOS)
   - Firefox (Android/Desktop)
   - Edge (Windows)

3. **Device Testing**
   - iOS devices (iPhone/iPad)
   - Android devices (various manufacturers)
   - Desktop browsers
   - Tablet form factors

4. **Offline Testing**
   - Network throttling
   - Complete offline scenarios
   - Intermittent connectivity
   - Background sync validation

5. **Installation Testing**
   - Add to Home Screen flow
   - App store readiness
   - Update mechanisms
   - Uninstallation process

### Testing Tools and Frameworks

```typescript
// PWA testing utilities
class PWATestUtils {
  async simulateOffline(): Promise<void> {
    await page.setOfflineMode(true)
  }
  
  async testInstallPrompt(): Promise<void> {
    await page.evaluate(() => {
      window.dispatchEvent(new Event('beforeinstallprompt'))
    })
  }
  
  async validateManifest(): Promise<ManifestValidation> {
    // Validate manifest.json structure
    // Check icon availability
    // Verify start_url accessibility
  }
}
```

## Performance Considerations

### PWA Performance Optimizations

1. **App Shell Architecture**
   - Minimal initial HTML
   - Critical CSS inlined
   - Progressive enhancement

2. **Resource Loading Strategy**
   - Preload critical resources
   - Lazy load non-critical content
   - Optimize image delivery

3. **Cache Management**
   - Intelligent cache invalidation
   - Storage quota management
   - Background cache updates

4. **Bundle Optimization**
   - Code splitting by route
   - Tree shaking unused code
   - Compression and minification

### Performance Metrics Targets

- **First Contentful Paint**: < 1.5s
- **Largest Contentful Paint**: < 2.5s
- **Time to Interactive**: < 3.5s
- **Cumulative Layout Shift**: < 0.1
- **First Input Delay**: < 100ms

## Security Considerations

### PWA Security Measures

1. **HTTPS Enforcement**
   - Service workers require HTTPS
   - Secure cookie handling
   - CSP headers implementation

2. **Data Protection**
   - Encrypt sensitive offline data
   - Secure push notification payloads
   - Validate all cached content

3. **Permission Management**
   - Granular notification permissions
   - Location access controls
   - Camera/microphone permissions

4. **Update Security**
   - Signed service worker updates
   - Manifest integrity checks
   - Secure update channels

## Deployment Strategy

### PWA Deployment Pipeline

1. **Build Process**
   ```bash
   npm run build          # Next.js build with PWA
   npm run export         # Static export if needed
   npm run lighthouse     # PWA audit
   ```

2. **Asset Optimization**
   - Icon generation (multiple sizes)
   - Manifest validation
   - Service worker compilation

3. **CDN Configuration**
   - Cache headers for static assets
   - Service worker delivery
   - Manifest.json serving

4. **Monitoring Setup**
   - PWA installation metrics
   - Offline usage analytics
   - Push notification delivery rates

This design provides a comprehensive foundation for implementing PWA capabilities while maintaining the existing StudioFlow architecture and functionality.